## Блок 1

### Задание 1 Проверка знания типов.

написать функцию, которая принимает разные типы параметров, и в зависимости от типа возвращает ответ.
нужны тесты на все типы. проверка типа осуществляется операторами typeof и instanceof.
первый подходит для простых типов, второй - для объектных.
можно воспользоваться конструкцией switch(item){ case '': break; default: ...}
number - возводит в квадрат.
string - возвращает длину
boolean - возвращает отрицание
объект - возвращает список ключей. подсказка, `Object.keys(obj).join(', ')`
массив - возвращает последний элемент
null - возвращает 'null'
NaN - возвращает 'NaN'
иначе (остался undefined) - возвращает 'undefined'

### Задание 2 callback, обработка исключений и работа с файлами

написать функцию `checkAndReturnLastChar(path: string, callback: (Error | undefined, string | undefined) => string): void`
в рамках решения разобраться, как импортировать функцию readFile (версия - callback), stat (также callback).
функция не должна падать ни при каких ошибках (try/catch).
сначала нужно проверить существование объекта по переданному пути (stat).
далее нужно проверить, что это - файл (`statResult.isFile()`)
если это файл, то его нужно прочитать в буффер (readFile), преобразовать в строку (toString), и вернуть через колбек предпоследний символ (`.at(-2)`).
на любом этапе в случае ошибки нужно вернуть вызовом ошибку: `callback(new Error('текст ошибки'))`.
будет три теста.
- по пути нет ничего - ошибка файл не найден
- по пути папка - ошибка, по указанному пути не файл
- по пути файл - предпоследний символ: Х


### Задание 3 Циклы
в теле модуля сгенерировать массив
```
let s = 1;
const array = new Array(100).fill(1).map(x => (s = (s * 2 + 1) % 101));
```
написать функцию, на вход которой передаётся вариант цикла, которым будет обрабатываться массив.
'for' - for(let i = 0; i < array.length; i++) {} // найти максимальный элемент и вернуть его
'for-in' - for(const i in array) {} // аналогично
'for-of' - for(const value of array) {} // аналогично
'while' - while(i < array.length) {} // аналогично
написать вызов каждого варианта.

### Задание 4 модификация массивов

в теле модуля сгенерировать массив
```
function getArray(): number[] {
  let s = 1;
  return new Array(100).fill(1).map(x => (s = (s * 2 + 1) % 101));
}
```
написать функцию, на вход которой передаётся вариант модификации.
исходный массив для модификации каждый раз получается вызовом getArray().
'pop-unshift' - составить новый массив, последовательно вытаскивая из конца первого (pop) добавляя в начало второго (unshift). вернуть первые 3 элемента в виде строки `slice(0, 3).join(', ')`
'shift-push' - составить новый массив, последовательно вытаскивая из начало первого (shift) добавляя в конец второго (push). вернуть первые 3 элемента в виде строки
'splice' - составить новый массив, удаляя текущий последний элемент массива через splice и вставляя его через push во второй. вернуть первые 3 элемента в виде строки
'sort' - отсортировать массив через callback-функцию в порядке убывания чисел. sort((a, b) => { ... }). вернуть первые 3 элемента в виде строки
'reverse' - инвертировать массив. вернуть первые 3 элемента в виде строки
'spread' - составить новый массив, убрав из него первые 2 элемента через spread `const [a, b, ...other]`. вернуть первые 3 элемента в виде строки
написать вызов каждого варианта.

### Задание 5 функции высшего порядка для массивов

написать функцию, на вход которой передаётся вариант модификации.
исходный массив для модификации каждый раз получается вызовом getArray() (см выше)
'forEach' array.forEach(x => {...}) // найти максимальный элемент и вернуть.
'map' array.map() // преобразовать массив, для каждого элемента получить его корень. вернуть первые 3 элемента в виде строки
'reduce' array.reduce() // вычислить результат по правилу. если элемент четный, то прибавить. иначе вычесть. вернуть числом результат
'filter' array.filter // отфильтровать массив, оставив там четные числа. вернуть первые 3 строкой
'flat' array.flat // преобразовать массив `[1, [2, [3, [4, [5, 6]]]], 7]` через flat, указав глубину 5, и вернуть первые 5 элементов строкой.


### Задание 6 date

а) написать функцию, которая принимает на вход строку, в которой записана дата,
и возвращает всегда дату в формате ISO 8601 (JSON). дата для примера: '01.12.2021'  
б) написать функцию, которая форматирует переданный объект даты в строку вида: "23ч 15м 56с"
с лидирующими нулями в локальном представлении (с учетом часового пояса). для примера - текущую дату  
в) написать функцию, которая для указанной даты рассчитывает и возвращает начало месяца
объектом даты (пример строкового представления результата: нулевая секунда 2023-12-01) с учетом локального часового пояса.

### Задание 7 Buffer
подготовить 2 файла, который будем читать.   
а) написать функцию, которая читает файл по указанному пути в Buffer (readFile),
и возвращает base64 (toString('base64')) от его первых 10 байт (slice).  
б) написать функцию, которая читает 2 файла (2 параметра функции), внутри
соединяет последовательно содержимое двух файлов (Buffer.concat), возвращает длину объединенного файла.  
в) написать функцию, которая читает файл по пути, преобразует его в текст
(toString) и возвращает последние 10 символов.

### Задание 8 throw + JSON
для этой задачи нужно подготовить 2 файла с записанным в нем JSON-объектом - валидным JSON и JSON с ошибками формата (например можно удалить первый "{" вначале).

написать функцию, возвращаюшую свой результат в callback(err, result). пусть она принимает путь к файлу, который надо открыть. открывает его fs.readFile(path, callback).

после чтения файла его нужно распарсить и вернуть в результате значение первого ключа объекта (Object.values(obj)[0]).  
если JSON невалиден, исключение с текстом - "JSON невалиден". если у объекта нет ни одного ключа (или не объект в корне), то - "JSON не содержит объект или ключи".

а) открывает валидный файл  
б) открывает невалидный файл. должно выдаваться в результате текст ошибки через callback и выдаваться в консоль

### Задание 9 таймеры
изучить работу с setTimeout/setInterval.  
а) написать функцию, которая через указываемое в первом параметре время возвращает передаваемое вторым параметром значение через callback. func(timeout, result, callback(err, result))

б) написать функцию func(msg, 1000, 5, callback(err)), которая будет писать в консоль 5 раз через каждые 1000 мс сообщение msg, а потом завершит свою работу через callback. отмена интервала - clearInterval.

в-г)* написать функцию, в которую передается путь к файлу и таймаут на его чтение. если файл успеется прочитаться до таймаута - то возвращать через callback его длину. иначе - ошибку `Файл не удалось прочитать за ${timeout} мс!`.

также должны обрабатываться ошибки вроде, что файл недоступен по пути. других побочных эффектов срабатывании другого исхода (файл прочитался после таймера и наоборот) быть не должно.

для "в" нужно показать сценарий, когда успели прочитать   
для "г" - не успели (можно сымитировать, управляя задержкой или добавляя ее перед чтением файла, например)


### Задание 10 функции высшего порядка + Regexp

а) написать функцию, которая на вход принимает число - через сколько секунд возвращать результат.  
она должна создавать и возвращать функцию, которая принимает один параметр и возвращает через callback результат через timeout время.  
особенность в том, что возвращаемая функция не должна иметь параметра-таймера

б) написать функцию, которая создает валидатор строк. на вход принимает Regexp и возвращает функцию,  
у которой один параметр - строка. эта функция должна возвращать true/false, соответствует ли строка регулярному выражению.

### Задание 11 eval
а) написать функцию, которая выполняет переданный в строке указанный код (eval),   
пытается обработать ошибку в его работе и через callback завершает свою работу - callback(err).

б) написать функцию-калькулятор, которая принимает арифметически   
корректное выражение строкой и возвращает через callback результат его выполнения.
